/*
 * =====================================================================================
 *
 *       Filename:  map.cpp
 *
 *    Description:  tread safe map, realized as balanced tree (without color).  
 *
 *        Version:  1.0
 *        Created:  17.05.2017 19:44:45
 *       Revision:  none
 *       Compiler:  g++ 4.9
 *
 *         Author:  Max Korchagin aka Vasy,  <vasy.chan@gmail.com>
 *
 * =====================================================================================
 */

#include <iostream>
#include <algorithm>
#include <memory>
#include <iterator>

template <typename T>
class node_iterator : public std::iterator<std::input_iterator_tag, T>
{
    private:

    public:
    T* _impl;

    node_iterator(T* impl):_impl(impl) {}
    node_iterator(const node_iterator<T>& new_it):_impl(new_it._impl) {}
    T& get() { return *_impl; }
    T& operator * () {return *_impl;}
    bool operator != (const node_iterator<T>& right) { return right._impl != this->_impl; } 
    T& operator ++ () { ++_impl; return *_impl; }
    T operator ++ (int)
        {
        T tmp(*_impl);
        operator ++();
        return tmp; 
        }
};

template<typename K, typename T>
struct Node 
{
    using _node = Node<K,T>;

    std::shared_ptr<Node<K,T>> m_parent = nullptr;
    std::shared_ptr<Node<K,T>> m_left = nullptr;
    std::shared_ptr<Node<K,T>> m_right = nullptr;
    K m_key;
    T m_value;

    Node():m_left(this)
        {
        }

    ~Node()
        {
        }

    Node(K key, T value)
        :m_key(key),
        m_value(value),
        m_left(this)
        {
        //m_left = this;
        }

    //TODO :statter, 110, make better 
    Node<K,T>(const Node<K,T>& right)
        {
        //Node<K,T>* dest = new Node();
        try
            {
            this->m_parent = right.m_parent;
            this->m_left = right.m_left;
            this->m_right = right.m_right;
            this->m_key = right.m_key;
            this->m_value = right.m_value;
            }
        catch(...)
            {
            throw;
            }
        }
    
    Node<K, T>& operator = (const Node<K, T>& right)
        {
        if ( *this != right )
            {
            Node<K, T>* new_node(right);
            this = new_node; 
            }
        return *this;
        }

    Node<K, T> operator * ()
        {
        return *this;
        }

    bool operator != (Node<K,T> right)
        {
        //std::cout << " operator != " << this->m_parent << " curr " << this->m_left << "  val " << this->m_value << " next " << this->m_right << "\n";
        //std::cout << " operator rigth != " << right.m_parent << " curr " << right.m_left << "  val " << right.m_value << " next " << right.m_right << "\n";
        if ( right.m_key != this->m_key )
            return true;
        return false;
        }
    
    // TODO: in-order tree
    Node<K, T>& operator ++ ()
        {
        if ( this->m_left )
            {
            this = m_left; 
            return *this
            }
        else 
            {
            this = m_right;
            return *this
            }
            //std::cout << " after operator ++  prev " << this->m_parent << " curr " << this->m_left << "  val " << this->m_value << " next " << this->m_right << "\n";
            }
        return *this;
        }


    Node<K, T> operator ++ (int)
        {
        //std::cout << " preincrement operatorn ++ \n";
        Node<K,T> tmp(*this);
        //std::cout << " tmp  prev " << tmp.m_parent << " curr " << tmp.m_left << "  val " << tmp.m_value << " next " << tmp.m_right << "\n";
        operator ++();
        //std::cout << " tmp after do operator ++  prev " << tmp.m_parent << " curr " << tmp.m_left << "  val " << tmp.m_value << " next " << tmp.m_right << "\n";
        return tmp; 
        }

    Node<K, T> operator == (const Node<K,T>& right)
        {
        if ( right.m_key == this->m_key )
            return true;
        return false;
        }

    Node<K, T> operator < (const Node<K,T>& right)
        {
        if (this->key < right.m_key )
            return true;
        return false;
        }
};



template <typename K, typename T, typename COMPARE = std::less<K>>
class Map 
{
    public:
    using _node = Node<K,T>;
    using _node_ptr = std::shared_ptr<Node<K,T>>;
    typedef node_iterator<Node<K, T>> iterator;

    iterator* m_begin = nullptr;
    iterator* m_end = nullptr;

    size_t _size = 0;

    private:

    void heapify( _node* i )
        {
        _node* left_leaf;
        _node* right_leaf;
        _node* largest_leaf;

        while ( true )
         {
            largest_leaf = i;
            left_leaf = i->prev;
            right_leaf = i->next;
       
            if ( left_leaf != end() &&  left_leaf  < largest_leaf )
            {
                largest_leaf = left_leaf;
            }
            if ( right_leaf != end() && right_leaf  < largest_leaf )
            {
                largest_leaf = right_leaf;
            }
            if ( largest_leaf == i ) 
                break;
            
            std::swap(i, largest_leaf); //NOde::Node(const Node&&) - move constructor
            i = largest_leaf;
            }
        }

    public:

    //typedef Node<K, T> iterator;

    iterator begin() { return *m_begin; };
    iterator end() { return *m_end; };
    
    const size_t size(){ return _size; }; const

    //Map<K,T>() {};  //TODO:

   
    // TODO: check for LEAKS
    void push_back(const std::pair<K, T>& data )
        {
        auto key = data.first;
        auto val = data.second;
        Node<K,T>* new_node = new Node<K,T>(key, val);
        if ( m_end != nullptr)
            {
            m_end->operator*().m_right = new_node->m_left;
            new_node->m_parent = m_end->_impl->m_left;
            }

        
        if ( !m_begin ) // this is our first node
            {
            m_begin = new iterator(new_node); 
            }
        m_end = new iterator(new_node);
        _size++; // increment size
        }
    
    // balanced insert (logN)
    void insert(const std::pair<K, T>& data)
    {
        auto heapsize = size();
        
        push_back(data);
        //data.push_back(leaf);
/*
        //auto parent = heapsize;
        auto parent = heapsize->;
        if ( heapsize % 2 == 0 )
        {
            parent = (heapsize/2) -1;
        }
        else
        {
            parent = ((heapsize -1)/2) -1;
        }
        auto leaf_id = data.size()- 1;
        while ( parent != leaf_id && data[parent] <= leaf )
        {
            //std::cout << "leaf_id " << leaf_id << ", data[leaf_id] = " << data[leaf_id] << " === > parent id " << parent << " data[parent] = " << data[parent] << "\n";
            std::swap(data[parent], data[leaf_id]);
            leaf_id = parent;
            parent = parent / 2 -1;
            if ( parent > data.size() )
                parent = 0;
        }
        */
    }

    /*
    // insert with iterator position
    void insert(iterator it, K key, T val)
        {
        Node<K,T>* new_node = new Node<K,T>(val);
        //m_begin++;
        //std::cout << " begin " <<  m_begin <<  " end " << m_end << " |  prev << " << it.m_parent  << " current = " << it->m_left << " value " << m_end->m_value << " next >> " << m_end->m_right << "\n";
        // setup new node
        new_node->m_parent = it.m_left;
        new_node->m_right = it.m_right;
        
        auto tmp = it.m_right;
        if (  tmp )
            {
            it.m_right = new_node;
            tmp->m_parent = new_node;
            }
        }
    */


};

//template <typename T>
//Node<T> map<T>::iterator = nullptr;

int main()
{

// defaut constructor
Map<int, int> testmap;
for (int i = 0; i <= 9; i++)
{
    testmap.push_back(std::pair<int, int>(i, i*2));
}


/*
map<int>::iterator test_it = testmap.begin();
test_it++;
test_it++;

testmap.insert(test_it, 200);

std::cout << " ========================== \n";

*/
int count =0;
while(++count < 9)
{
    
}
//for ( auto&& i : testmap )
for ( Map<int,int>::iterator it = testmap.begin(); it != testmap.end(); it++)
{
    //std::cout << " prev " << *(i).m_parent << " self " << i.m_left << " key " << i.m_key <<  "  val " << i.m_value << " next " << i.m_right << "\n";
    auto lnode = **it;
    std::cout << " key " << lnode.m_key <<  "  val " << lnode.m_value  << "\n";
}
return 0;
}
